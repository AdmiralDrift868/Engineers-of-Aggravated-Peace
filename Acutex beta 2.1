#!/usr/bin/env python3
"""
AcuTex Ballistic Calculator - Ultimate Edition
Combines features from all provided scripts with bug fixes and improvements
"""

import sys
import math
import csv
import json
import os
import logging
import random
from functools import lru_cache
from typing import Dict, Any, List, Optional, Tuple

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLabel, QLineEdit, QPushButton, QComboBox, QTabWidget,
    QGroupBox, QDoubleSpinBox, QSpinBox, QTextEdit, QCheckBox,
    QFileDialog, QMessageBox, QInputDialog, QScrollArea, QSizePolicy,
    QGridLayout, QTableWidget, QTableWidgetItem, QProgressBar, QStatusBar
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal
from PyQt5.QtGui import QIcon, QFont
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
from matplotlib.figure import Figure

# Constants
GRAVITY = 9.80665  # m/s^2
EARTH_RADIUS = 6371000  # meters
EARTH_ROTATION_RATE = 7.292115e-5  # rad/s
SPEED_OF_SOUND = 343  # m/s at sea level

PRESET_FILE = "user_presets.json"
CONFIG_FILE = "user_config.json"

logging.basicConfig(
    filename="ballistic.log",
    level=logging.INFO,
    format="%(asctime)s %(levelname)s: %(message)s"
)


def log(msg: str, level="info"):
    getattr(logging, level, logging.info)(msg)


def clamp(val, vmin, vmax):
    return max(vmin, min(val, vmax))


def linear_interpolate(x, x0, x1, y0, y1):
    if x1 == x0:
        return y0
    return y0 + ((y1 - y0) * (x - x0) / (x1 - x0))


def interpolate_curve(x, curve: List[Tuple[float, float]]):
    if not curve or len(curve) < 2:
        return curve[0][1] if curve else 0.0
    curve = sorted(curve)
    xs, ys = zip(*curve)
    if x <= xs[0]:
        return ys[0]
    if x >= xs[-1]:
        return ys[-1]
    for i in range(1, len(xs)):
        if x < xs[i]:
            return linear_interpolate(x, xs[i - 1], xs[i], ys[i - 1], ys[i])
    return ys[-1]


class DragModel:
    """Enhanced drag coefficient tables for standard models."""

    @staticmethod
    @lru_cache(maxsize=4096)
    def G1(velocity: float) -> float:
        mach = velocity / SPEED_OF_SOUND
        if mach > 4.0: return 0.45
        elif mach > 3.0: return 0.42
        elif mach > 2.5: return 0.40
        elif mach > 2.0: return 0.38
        elif mach > 1.5: return 0.35
        elif mach > 1.2: return 0.33
        elif mach > 1.0: return 0.31
        elif mach > 0.9: return 0.30
        elif mach > 0.8: return 0.29
        elif mach > 0.7: return 0.28
        elif mach > 0.6: return 0.27
        else: return 0.25

    @staticmethod
    @lru_cache(maxsize=4096)
    def G7(velocity: float) -> float:
        mach = velocity / SPEED_OF_SOUND
        if mach > 4.0: return 0.38
        elif mach > 3.0: return 0.36
        elif mach > 2.5: return 0.34
        elif mach > 2.0: return 0.32
        elif mach > 1.5: return 0.30
        elif mach > 1.2: return 0.28
        elif mach > 1.0: return 0.26
        elif mach > 0.9: return 0.25
        elif mach > 0.8: return 0.24
        elif mach > 0.7: return 0.23
        elif mach > 0.6: return 0.22
        else: return 0.21

    @staticmethod
    @lru_cache(maxsize=4096)
    def rocket(velocity: float) -> float:
        mach = velocity / SPEED_OF_SOUND
        if mach > 3.0: return 0.50
        elif mach > 2.0: return 0.45
        elif mach > 1.5: return 0.40
        elif mach > 1.0: return 0.35
        elif mach > 0.8: return 0.30
        else: return 0.25

    @staticmethod
    @lru_cache(maxsize=4096)
    def mortar(velocity: float) -> float:
        mach = velocity / SPEED_OF_SOUND
        if mach > 1.5: return 0.55
        elif mach > 1.0: return 0.50
        elif mach > 0.8: return 0.45
        else: return 0.40

    @staticmethod
    def custom(velocity: float, curve: List[Tuple[float, float]]) -> float:
        return interpolate_curve(velocity, curve)


class Projectile:
    """Projectile model for physics and mass/thrust properties."""

    def __init__(
        self, mass: float = 0.01, diameter: float = 0.01, drag_model: str = 'G7',
        velocity: float = 800, projectile_type: str = 'bullet',
        thrust_curve: Optional[Dict[float, float]] = None,
        burn_time: float = 0, custom_drag_curve: Optional[List[Tuple[float, float]]] = None
    ):
        self.mass = mass  # kg
        self.diameter = diameter  # meters
        self.drag_model = drag_model
        self.velocity = velocity  # m/s
        self.area = math.pi * (diameter/2)**2
        self.projectile_type = projectile_type
        self.thrust_curve = thrust_curve or {}
        self.burn_time = burn_time
        self.initial_mass = mass
        self.custom_drag_curve = custom_drag_curve

    def drag_coefficient(self, velocity: float) -> float:
        """Get drag coefficient based on current velocity."""
        if self.drag_model == 'G1':
            return DragModel.G1(velocity)
        elif self.drag_model == 'G7':
            return DragModel.G7(velocity)
        elif self.drag_model == 'rocket':
            return DragModel.rocket(velocity)
        elif self.drag_model == 'mortar':
            return DragModel.mortar(velocity)
        elif self.drag_model == 'Custom' and self.custom_drag_curve:
            return DragModel.custom(velocity, self.custom_drag_curve)
        else:
            return 0.3  # Default for other models

    def get_thrust(self, time: float) -> float:
        """Get current thrust based on thrust curve."""
        if time > self.burn_time:
            return 0
        times = sorted(self.thrust_curve.keys())
        if not times:
            return 0
        if time <= times[0]:
            return self.thrust_curve[times[0]]
        if time >= times[-1]:
            return self.thrust_curve[times[-1]]
        for i in range(1, len(times)):
            if time <= times[i]:
                t0, t1 = times[i-1], times[i]
                f0, f1 = self.thrust_curve[t0], self.thrust_curve[t1]
                return f0 + (f1 - f0) * (time - t0) / (t1 - t0)
        return 0

    def get_mass(self, time: float) -> float:
        """Calculate current mass based on burn time."""
        if self.projectile_type != 'rocket' or time > self.burn_time:
            return self.mass
        return self.initial_mass - (self.initial_mass - self.mass) * (time / self.burn_time)


class Environment:
    """Environment model for air density and weather effects."""

    def __init__(
        self, altitude: float = 0, temperature: float = 15, pressure: float = 1013.25,
        humidity: float = 50, wind_speed: float = 0, wind_angle: float = 0,
        coriolis: bool = False, latitude: float = 45
    ):
        self.altitude = altitude  # meters
        self.temperature = temperature  # Â°C
        self.pressure = pressure  # hPa
        self.humidity = humidity  # %
        self.wind_speed = wind_speed  # m/s
        self.wind_angle = wind_angle  # degrees
        self.coriolis = coriolis
        self.latitude = latitude
        self.air_density = self.calculate_air_density()

    @lru_cache(maxsize=128)
    def calculate_air_density(self) -> float:
        """Improved air density calculation using CIPM-2007 equation."""
        temp_kelvin = self.temperature + 273.15
        R = 287.058  # Specific gas constant for dry air
        svp = 6.1078 * 10 ** ((7.5 * self.temperature) / (self.temperature + 237.3))
        vp = svp * self.humidity / 100
        density = ((self.pressure * 100) / (R * temp_kelvin)) * (1 - (0.378 * vp) / (self.pressure * 100))
        density *= math.exp(-self.altitude / 10000)
        return density

# ... continue in next part ...
# ...continued from previous part...

class CalculationThread(QThread):
    finished = pyqtSignal(list)
    error = pyqtSignal(str)
    def __init__(self, calculator: 'BallisticCalculator', params: Dict[str, Any]):
        super().__init__()
        self.calculator = calculator
        self.params = params
        
    def run(self):
        try:
            result = self.calculator._calculate_trajectory(**self.params)
            self.finished.emit(result)
        except Exception as e:
            self.error.emit(str(e))

class BatchCalculationThread(QThread):
    finished = pyqtSignal(list)
    error = pyqtSignal(str)
    progress = pyqtSignal(int)
    
    def __init__(self, calculator: 'BallisticCalculator', batch_params: List[Dict[str, Any]]):
        super().__init__()
        self.calculator = calculator
        self.batch_params = batch_params
        
    def run(self):
        results = []
        try:
            total = len(self.batch_params)
            for i, params in enumerate(self.batch_params):
                results.append(self.calculator._calculate_trajectory(**params))
                self.progress.emit(int((i+1)/total*100))
            self.finished.emit(results)
        except Exception as e:
            self.error.emit(str(e))

class BallisticCalculator(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("AcuTex Ballistic Calculator - Ultimate Edition")
        self.setGeometry(100, 100, 1200, 950)
        self.setMinimumSize(800, 600)
        
        # Initialize state variables
        self.trajectory: List[Any] = []
        self.previous_trajectories: List[Any] = []
        self.dark_mode_enabled = False
        self.use_imperial = False
        self.custom_drag_curve: Optional[List[Tuple[float, float]]] = None
        
        # Load presets and config
        self.default_presets = self.load_default_presets()
        self.presets = self.load_presets()
        self.config = self.load_config()
        self.apply_config()
        
        # Initialize UI
        self.init_ui()
        self.apply_styles()
        log("AcuTex Ballistic Calculator started")
        
        # Status bar
        self.status_bar = self.statusBar()
        self.status_bar.showMessage("Ready")

    # ... (the rest of BallisticCalculator continues here - see next part) ...
        def load_default_presets(self) -> Dict[str, Any]:

   """Return the hardcoded default presets"""
   # [ ... Large preset dictionary, unchanged ... ]
        # For brevity, not repeating the 100+ lines of preset dictionary.
        # Use your current default_presets implementation here.
        # --- End of large preset dictionary ---
        return {
            # (Your preset dictionary as in previous code)
        }

    def load_presets(self) -> Dict[str, Any]:
        presets = self.default_presets.copy()
        if os.path.exists(PRESET_FILE):
            try:
                with open(PRESET_FILE, "r") as f:
                    user_presets = json.load(f)
                    presets.update(user_presets)
            except Exception as e:
                log(f"Failed to load custom presets: {e}", "warning")
        return presets

    def save_presets(self):
        user_presets = {k: v for k, v in self.presets.items() if k not in self.default_presets}
        try:
            with open(PRESET_FILE, "w") as f:
                json.dump(user_presets, f, indent=2)
        except Exception as e:
            log(f"Failed to save custom presets: {e}", "warning")

    def load_config(self):
        if os.path.exists(CONFIG_FILE):
            try:
                with open(CONFIG_FILE, "r") as f:
                    return json.load(f)
            except Exception as e:
                log(f"Failed to load config: {e}", "warning")
        return {}

    def save_config(self):
        data = {
            "dark_mode": self.dark_mode_enabled,
            "imperial": self.use_imperial
        }
        try:
            with open(CONFIG_FILE, "w") as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            log(f"Failed to save config: {e}", "warning")

    def apply_config(self):
        self.dark_mode_enabled = self.config.get("dark_mode", False)
        self.use_imperial = self.config.get("imperial", False)

    def apply_styles(self):
        if self.dark_mode_enabled:
            self.setStyleSheet("""
                QMainWindow { background-color: #23272e; color: #eee; font-family: Segoe UI, Arial; }
                QGroupBox { border: 1px solid #444; border-radius: 4px; margin-top: 10px; padding-top: 15px; color: #eee; }
                QGroupBox::title { color: #aaa; }
                QPushButton { background-color: #33364a; color: #eaeaea; border: 1px solid #888; border-radius: 3px; padding: 5px 10px; }
                QPushButton:hover { background-color: #40445c; }
                QLineEdit, QTextEdit, QComboBox, QSpinBox, QDoubleSpinBox { 
                    border: 1px solid #666; color: #eee; background: #282c34; 
                    border-radius: 3px; padding: 3px;
                }
                QTabWidget::pane { border: 1px solid #333; }
                QTabBar::tab { padding: 5px 10px; }
                QTableWidget { background-color: #282c34; gridline-color: #444; }
                QHeaderView::section { background-color: #333; color: #eee; }
                QProgressBar {
                    border: 1px solid #444;
                    border-radius: 3px;
                    text-align: center;
                    background: #282c34;
                }
                QProgressBar::chunk {
                    background-color: #3daee9;
                    width: 10px;
                }
            """)
        else:
            self.setStyleSheet("""
                QMainWindow { background-color: #f5f5f5; font-family: Segoe UI, Arial; }
                QGroupBox { border: 1px solid #ccc; border-radius: 4px; margin-top: 10px; padding-top: 15px; }
                QGroupBox::title { color: #555; }
                QPushButton { 
                    background-color: #e0e0e0; border: 1px solid #aaa; border-radius: 3px; padding: 5px 10px;
                }
                QPushButton:hover { background-color: #d0d0d0; }
                QLineEdit, QTextEdit, QComboBox, QSpinBox, QDoubleSpinBox { 
                    border: 1px solid #bbb; border-radius: 3px; padding: 3px;
                }
                QTabWidget::pane { border: 1px solid #ccc; }
                QTabBar::tab { padding: 5px 10px; }
                QTableWidget { gridline-color: #ddd; }
                QProgressBar {
                    border: 1px solid #ccc;
                    border-radius: 3px;
                    text-align: center;
                }
                QProgressBar::chunk {
                    background-color: #4CAF50;
                    width: 10px;
                }
            """)

    # ...continues with the BallisticCalculator UI and logic...
        def init_ui(self):
        # Create main widget and layout
        main_widget = QWidget()
        main_layout = QVBoxLayout(main_widget)
        main_layout.setContentsMargins(5, 5, 5, 5)

        # Create tabs
        self.tabs = QTabWidget()
        self.tabs.addTab(self.create_input_tab(), "Input")
        self.tabs.addTab(self.create_results_tab(), "Results")
        self.tabs.addTab(self.create_plot_tab(), "Graph")
        self.tabs.addTab(self.create_batch_tab(), "Batch Mode")
        self.tabs.addTab(self.create_monte_carlo_tab(), "Monte Carlo")
        self.tabs.addTab(self.create_settings_tab(), "Settings")
        self.tabs.addTab(self.create_help_tab(), "Help")

        main_layout.addWidget(self.tabs, 1)
        self.setCentralWidget(main_widget)

        # Menu bar
        menubar = self.menuBar()
        file_menu = menubar.addMenu('File')

        export_action = file_menu.addAction('Export CSV')
        export_action.triggered.connect(self.export_to_csv)

        export_plot_action = file_menu.addAction("Export Plot as PNG")
        export_plot_action.triggered.connect(self.export_plot_to_png)

        exit_action = file_menu.addAction('Exit')
        exit_action.triggered.connect(self.close)

        view_menu = menubar.addMenu('View')
        self.dark_mode_action = view_menu.addAction("Toggle Dark Mode")
        self.dark_mode_action.setCheckable(True)
        self.dark_mode_action.setChecked(self.dark_mode_enabled)
        self.dark_mode_action.triggered.connect(self.toggle_dark_mode)

        help_menu = menubar.addMenu('Help')
        about_action = help_menu.addAction('About')
        about_action.triggered.connect(self.show_about)

    # ...continues with create_input_tab, create_results_tab, create_plot_tab, etc...

    def create_input_tab(self):
        tab = QWidget()
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        container = QWidget()
        layout = QVBoxLayout(container)

        # Projectile Type Selection
        type_group = QGroupBox("Projectile Type")
        type_layout = QHBoxLayout()

        self.type_combo = QComboBox()
        self.type_combo.addItems(["Bullet", "Rocket", "Mortar"])
        self.type_combo.currentTextChanged.connect(self.update_projectile_type)
        type_layout.addWidget(QLabel("Type:"))
        type_layout.addWidget(self.type_combo)

        type_group.setLayout(type_layout)
        layout.addWidget(type_group)

        # Preset Selection
        preset_group = QGroupBox("Ammunition Presets")
        preset_layout = QHBoxLayout()

        self.preset_combo = QComboBox()
        self.preset_combo.setEditable(True)
        self.refresh_preset_combo()
        self.preset_combo.currentTextChanged.connect(self.on_preset_change)
        preset_layout.addWidget(self.preset_combo)

        load_btn = QPushButton("Load Preset")
        load_btn.clicked.connect(self.load_preset)
        save_btn = QPushButton("Save Current")
        save_btn.clicked.connect(self.save_preset)
        delete_btn = QPushButton("Delete Preset")
        delete_btn.clicked.connect(self.delete_preset)

        preset_layout.addWidget(load_btn)
        preset_layout.addWidget(save_btn)
        preset_layout.addWidget(delete_btn)

        preset_group.setLayout(preset_layout)
        layout.addWidget(preset_group)

        # Projectile Group
        proj_group = QGroupBox("Projectile Parameters")
        proj_layout = QGridLayout()

        # Mass
        proj_layout.addWidget(QLabel("Mass (g):"), 0, 0)
        self.mass_input = QDoubleSpinBox()
        self.mass_input.setRange(0.1, 1000000)
        self.mass_input.setValue(10)
        proj_layout.addWidget(self.mass_input, 0, 1)

        # Diameter
        proj_layout.addWidget(QLabel("Diameter (mm):"), 1, 0)
        self.diam_input = QDoubleSpinBox()
        self.diam_input.setRange(0.1, 1000)
        self.diam_input.setValue(7.62)
        proj_layout.addWidget(self.diam_input, 1, 1)

        # Drag Model
        proj_layout.addWidget(QLabel("Drag Model:"), 2, 0)
        self.drag_model_combo = QComboBox()
        self.drag_model_combo.addItems(['G1', 'G7', 'rocket', 'mortar', 'Custom'])
        proj_layout.addWidget(self.drag_model_combo, 2, 1)

        drag_curve_btn = QPushButton("Load Custom Drag")
        drag_curve_btn.clicked.connect(self.load_custom_drag_curve)
        proj_layout.addWidget(drag_curve_btn, 2, 2)

        # Rocket-specific parameters
        self.rocket_group = QGroupBox("Rocket Parameters")
        rocket_layout = QVBoxLayout()

        burn_layout = QHBoxLayout()
        burn_layout.addWidget(QLabel("Burn Time (s):"))
        self.burn_time_input = QDoubleSpinBox()
        self.burn_time_input.setRange(0, 10)
        self.burn_time_input.setValue(1.0)
        self.burn_time_input.setSingleStep(0.1)
        burn_layout.addWidget(self.burn_time_input)
        rocket_layout.addLayout(burn_layout)

        thrust_layout = QHBoxLayout()
        thrust_layout.addWidget(QLabel("Avg Thrust (N):"))
        self.thrust_input = QDoubleSpinBox()
        self.thrust_input.setRange(0, 10000)
        self.thrust_input.setValue(1000)
        self.thrust_input.setSingleStep(100)
        thrust_layout.addWidget(self.thrust_input)
        rocket_layout.addLayout(thrust_layout)

        self.rocket_group.setLayout(rocket_layout)
        self.rocket_group.setVisible(False)
        proj_layout.addWidget(self.rocket_group, 3, 0, 1, 3)

        proj_group.setLayout(proj_layout)
        layout.addWidget(proj_group)

        # ...continues with launch parameters, environment group, and rest of UI...

        scroll.setWidget(container)
        tab_layout = QVBoxLayout(tab)
        tab_layout.addWidget(scroll)
        return tab

# ...continues in next part...
        # Launch Parameters Group
        launch_group = QGroupBox("Launch Parameters")
        launch_layout = QGridLayout()

        # Velocity
        launch_layout.addWidget(QLabel("Muzzle Velocity (m/s):"), 0, 0)
        self.velocity_input = QDoubleSpinBox()
        self.velocity_input.setRange(1, 5000)
        self.velocity_input.setValue(800)
        launch_layout.addWidget(self.velocity_input, 0, 1)

        # Angle
        launch_layout.addWidget(QLabel("Launch Angle (deg):"), 1, 0)
        self.angle_input = QDoubleSpinBox()
        self.angle_input.setRange(0, 90)
        self.angle_input.setValue(15)
        launch_layout.addWidget(self.angle_input, 1, 1)

        launch_group.setLayout(launch_layout)
        layout.addWidget(launch_group)

        # Environment Group
        env_group = QGroupBox("Environmental Parameters")
        env_layout = QGridLayout()

        # Altitude
        env_layout.addWidget(QLabel("Altitude (m):"), 0, 0)
        self.altitude_input = QDoubleSpinBox()
        self.altitude_input.setRange(-100, 10000)
        self.altitude_input.setValue(0)
        env_layout.addWidget(self.altitude_input, 0, 1)

        # Temperature
        env_layout.addWidget(QLabel("Temperature (Â°C):"), 1, 0)
        self.temp_input = QDoubleSpinBox()
        self.temp_input.setRange(-50, 60)
        self.temp_input.setValue(15)
        env_layout.addWidget(self.temp_input, 1, 1)

        # Pressure
        env_layout.addWidget(QLabel("Pressure (hPa):"), 2, 0)
        self.pressure_input = QDoubleSpinBox()
        self.pressure_input.setRange(800, 1100)
        self.pressure_input.setValue(1013.25)
        env_layout.addWidget(self.pressure_input, 2, 1)

        # Humidity
        env_layout.addWidget(QLabel("Humidity (%):"), 3, 0)
        self.humidity_input = QDoubleSpinBox()
        self.humidity_input.setRange(0, 100)
        self.humidity_input.setValue(50)
        env_layout.addWidget(self.humidity_input, 3, 1)

        # Wind
        env_layout.addWidget(QLabel("Wind Speed (m/s):"), 4, 0)
        self.wind_speed_input = QDoubleSpinBox()
        self.wind_speed_input.setRange(0, 50)
        self.wind_speed_input.setValue(0)
        env_layout.addWidget(self.wind_speed_input, 4, 1)

        env_layout.addWidget(QLabel("Wind Angle (deg):"), 5, 0)
        self.wind_angle_input = QSpinBox()
        self.wind_angle_input.setRange(0, 359)
        self.wind_angle_input.setValue(0)
        env_layout.addWidget(self.wind_angle_input, 5, 1)

        # Advanced options
        self.coriolis_check = QCheckBox("Coriolis Effect")
        env_layout.addWidget(self.coriolis_check, 6, 0)

        env_layout.addWidget(QLabel("Latitude:"), 6, 1)
        self.latitude_input = QDoubleSpinBox()
        self.latitude_input.setRange(-90, 90)
        self.latitude_input.setValue(45)
        self.latitude_input.setEnabled(False)
        env_layout.addWidget(self.latitude_input, 6, 2)

        self.coriolis_check.stateChanged.connect(
            lambda: self.latitude_input.setEnabled(self.coriolis_check.isChecked()))

        env_group.setLayout(env_layout)
        layout.addWidget(env_group)

        # Calculate button
        calc_row = QHBoxLayout()
        self.calculate_btn = QPushButton("Calculate Trajectory")
        self.calculate_btn.clicked.connect(self.calculate_trajectory)
        calc_row.addWidget(self.calculate_btn)

        export_btn = QPushButton("Export Results")
        export_btn.clicked.connect(self.export_results)
        calc_row.addWidget(export_btn)

        export_plot_btn = QPushButton("Export Plot")
        export_plot_btn.clicked.connect(self.export_plot)
        calc_row.addWidget(export_plot_btn)

        layout.addLayout(calc_row)

        scroll.setWidget(container)
        tab_layout = QVBoxLayout(tab)
        tab_layout.addWidget(scroll)
        return tab

    # ...continues with create_results_tab, create_plot_tab, create_batch_tab, create_monte_carlo_tab, create_settings_tab, create_help_tab, and the rest of the methods...

    def create_results_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # Summary Group
        summary_group = QGroupBox("Summary Results")
        summary_layout = QVBoxLayout()

        self.summary_text = QTextEdit()
        self.summary_text.setReadOnly(True)
        scroll = QScrollArea()
        scroll.setWidget(self.summary_text)
        scroll.setWidgetResizable(True)
        summary_layout.addWidget(scroll)
        summary_group.setLayout(summary_layout)

        # Data Group
        data_group = QGroupBox("Trajectory Data")
        data_layout = QVBoxLayout()

        self.data_text = QTextEdit()
        self.data_text.setReadOnly(True)
        scroll_data = QScrollArea()
        scroll_data.setWidget(self.data_text)
        scroll_data.setWidgetResizable(True)
        data_layout.addWidget(scroll_data)
        data_group.setLayout(data_layout)

        layout.addWidget(summary_group, 1)
        layout.addWidget(data_group, 2)
        return tab

    # ...next part will continue with the rest of the tab creators and methods...
    def create_plot_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)

        self.figure = Figure(figsize=(5, 4), dpi=100)
        self.canvas = FigureCanvas(self.figure)
        self.canvas.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        self.nav_toolbar = NavigationToolbar(self.canvas, self)

        layout.addWidget(self.nav_toolbar)
        layout.addWidget(self.canvas, 1)

        # Comparison checkbox at bottom
        bottom_layout = QHBoxLayout()
        self.compare_check = QCheckBox("Compare with previous trajectory")
        bottom_layout.addWidget(self.compare_check)
        bottom_layout.addStretch(1)

        layout.addLayout(bottom_layout)
        return tab

    def create_batch_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # Batch controls
        controls_group = QGroupBox("Batch Parameters")
        controls_layout = QGridLayout()

        controls_layout.addWidget(QLabel("Sweep parameter:"), 0, 0)
        self.batch_param_combo = QComboBox()
        self.batch_param_combo.addItems(["Angle", "Muzzle Velocity"])
        controls_layout.addWidget(self.batch_param_combo, 0, 1)

        controls_layout.addWidget(QLabel("Start:"), 1, 0)
        self.batch_start_input = QDoubleSpinBox()
        self.batch_start_input.setRange(-10000, 10000)
        self.batch_start_input.setValue(10)
        controls_layout.addWidget(self.batch_start_input, 1, 1)

        controls_layout.addWidget(QLabel("End:"), 2, 0)
        self.batch_end_input = QDoubleSpinBox()
        self.batch_end_input.setRange(-10000, 10000)
        self.batch_end_input.setValue(80)
        controls_layout.addWidget(self.batch_end_input, 2, 1)

        controls_layout.addWidget(QLabel("Step:"), 3, 0)
        self.batch_step_input = QDoubleSpinBox()
        self.batch_step_input.setRange(0.001, 10000)
        self.batch_step_input.setValue(5)
        controls_layout.addWidget(self.batch_step_input, 3, 1)

        self.batch_run_btn = QPushButton("Run Batch")
        self.batch_run_btn.clicked.connect(self.run_batch)
        controls_layout.addWidget(self.batch_run_btn, 3, 2)

        controls_group.setLayout(controls_layout)
        layout.addWidget(controls_group)

        # Progress bar
        self.batch_progress_bar = QProgressBar()
        layout.addWidget(self.batch_progress_bar)

        # Results table
        self.batch_table = QTableWidget()
        self.batch_table.setColumnCount(5)
        self.batch_table.setHorizontalHeaderLabels([
            "Run", "Param Value", "Max Height (m)", "Distance (m)", "Impact Vel (m/s)"
        ])
        layout.addWidget(self.batch_table, 1)

        return tab

    def create_monte_carlo_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # Monte Carlo controls
        controls_group = QGroupBox("Monte Carlo Parameters")
        controls_layout = QGridLayout()

        controls_layout.addWidget(QLabel("Number of Runs:"), 0, 0)
        self.mc_runs_input = QSpinBox()
        self.mc_runs_input.setRange(10, 1000)
        self.mc_runs_input.setValue(100)
        controls_layout.addWidget(self.mc_runs_input, 0, 1)

        controls_layout.addWidget(QLabel("Angle Spread (Â±deg):"), 1, 0)
        self.mc_spread_angle = QDoubleSpinBox()
        self.mc_spread_angle.setRange(0, 10)
        self.mc_spread_angle.setValue(0.5)
        controls_layout.addWidget(self.mc_spread_angle, 1, 1)

        controls_layout.addWidget(QLabel("Velocity Spread (Â±m/s):"), 2, 0)
        self.mc_spread_velocity = QDoubleSpinBox()
        self.mc_spread_velocity.setRange(0, 100)
        self.mc_spread_velocity.setValue(5)
        controls_layout.addWidget(self.mc_spread_velocity, 2, 1)

        self.mc_run_btn = QPushButton("Run Monte Carlo")
        self.mc_run_btn.clicked.connect(self.run_monte_carlo)
        controls_layout.addWidget(self.mc_run_btn, 2, 2)

        controls_group.setLayout(controls_layout)
        layout.addWidget(controls_group)

        # Progress bar
        self.mc_progress_bar = QProgressBar()
        layout.addWidget(self.mc_progress_bar)

        # Plot canvas
        self.mc_canvas = FigureCanvas(Figure(figsize=(5, 4), dpi=100))
        layout.addWidget(self.mc_canvas, 1)

        return tab

    def create_settings_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # Units settings
        units_group = QGroupBox("Units")
        units_layout = QVBoxLayout()

        self.units_chk = QCheckBox("Use Imperial Units")
        self.units_chk.setChecked(self.use_imperial)
        self.units_chk.stateChanged.connect(self.toggle_units)
        units_layout.addWidget(self.units_chk)

        units_group.setLayout(units_layout)
        layout.addWidget(units_group)

        # Theme settings
        theme_group = QGroupBox("Appearance")
        theme_layout = QVBoxLayout()

        self.dark_mode_chk = QCheckBox("Enable Dark Mode")
        self.dark_mode_chk.setChecked(self.dark_mode_enabled)
        self.dark_mode_chk.stateChanged.connect(self.toggle_dark_mode)
        theme_layout.addWidget(self.dark_mode_chk)

        theme_group.setLayout(theme_layout)
        layout.addWidget(theme_group)

        # Preset management
        preset_group = QGroupBox("Preset Management")
        preset_layout = QVBoxLayout()

        self.preset_export_btn = QPushButton("Export Presets")
        self.preset_export_btn.clicked.connect(self.export_presets)
        preset_layout.addWidget(self.preset_export_btn)

        self.preset_import_btn = QPushButton("Import Presets")
        self.preset_import_btn.clicked.connect(self.import_presets)
        preset_layout.addWidget(self.preset_import_btn)

        preset_group.setLayout(preset_layout)
        layout.addWidget(preset_group)

        layout.addStretch(1)
        return tab

    def create_help_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)

        help_text = QTextEdit()
        help_text.setReadOnly(True)
        help_text.setFont(QFont("Segoe UI", 11))
        help_text.setPlainText(
            "AcuTex Ballistic Calculator Help\n\n"
            "â¢ Input: Enter all projectile and environmental parameters, or select from presets.\n"
            "â¢ Projectile Type: Choose between Bullet, Rocket, or Mortar.\n"
            "â¢ Drag Models: Select appropriate drag model for your projectile type.\n"
            "â¢ Rocket Parameters: Configure burn time and thrust for rocket projectiles.\n"
            "â¢ Environmental Factors: Adjust altitude, temperature, pressure, humidity, and wind.\n"
            "â¢ Coriolis Effect: Enable to account for Earth's rotation (latitude required).\n\n"
            "â¢ Batch Mode: Sweep angle or velocity and compute multiple trajectories.\n"
            "â¢ Monte Carlo: Simulate random variations in angle and velocity to see spread.\n\n"
            "â¢ Export: Save trajectory data as CSV or plot as PNG image.\n"
            "â¢ Settings: Toggle between metric and imperial units, dark mode, and manage presets.\n\n"
            "All fields have tooltips - hover over them for more information."
        )
        layout.addWidget(help_text)
        return tab

    # ...next part will include refresh_preset_combo, update_projectile_type,
    # on_preset_change, load_preset, save_preset, delete_preset, load_custom_drag_curve,
    # toggle_dark_mode, toggle_units, validate_inputs, calculate_trajectory, and more...
        def refresh_preset_combo(self):
        self.preset_combo.blockSignals(True)
        self.preset_combo.clear()
        self.preset_combo.addItems(sorted(self.presets.keys()))
        self.preset_combo.blockSignals(False)

    def update_projectile_type(self):
        typ = self.type_combo.currentText()
        if typ.lower() == "rocket":
            self.rocket_group.setVisible(True)
        else:
            self.rocket_group.setVisible(False)

    def on_preset_change(self, preset_name: str):
        if preset_name in self.presets:
            self.load_preset()

    def load_preset(self):
        preset_name = self.preset_combo.currentText()
        preset = self.presets.get(preset_name)
        if preset:
            self.mass_input.setValue(preset.get("mass", 10))
            self.diam_input.setValue(preset.get("diameter", 7.62))
            self.velocity_input.setValue(preset.get("velocity", 800))
            self.angle_input.setValue(preset.get("angle", 15))
            self.drag_model_combo.setCurrentText(preset.get("drag_model", "G7"))
            self.type_combo.setCurrentText(preset.get("type", "Bullet"))
            if preset.get("type", "").lower() == "rocket":
                self.burn_time_input.setValue(preset.get("burn_time", 1.0))
                self.thrust_input.setValue(preset.get("thrust", 1000))
            self.altitude_input.setValue(preset.get("altitude", 0))
            self.temp_input.setValue(preset.get("temperature", 15))
            self.pressure_input.setValue(preset.get("pressure", 1013.25))
            self.humidity_input.setValue(preset.get("humidity", 50))
            self.wind_speed_input.setValue(preset.get("wind_speed", 0))
            self.wind_angle_input.setValue(preset.get("wind_angle", 0))
            self.coriolis_check.setChecked(preset.get("coriolis", False))
            self.latitude_input.setValue(preset.get("latitude", 45))
            QMessageBox.information(self, "Preset Loaded", f"Preset '{preset_name}' loaded.")

    def save_preset(self):
        name, ok = QInputDialog.getText(self, "Save Preset", "Enter preset name:")
        if ok and name:
            preset = {
                "mass": self.mass_input.value(),
                "diameter": self.diam_input.value(),
                "velocity": self.velocity_input.value(),
                "angle": self.angle_input.value(),
                "drag_model": self.drag_model_combo.currentText(),
                "type": self.type_combo.currentText(),
                "burn_time": self.burn_time_input.value(),
                "thrust": self.thrust_input.value(),
                "altitude": self.altitude_input.value(),
                "temperature": self.temp_input.value(),
                "pressure": self.pressure_input.value(),
                "humidity": self.humidity_input.value(),
                "wind_speed": self.wind_speed_input.value(),
                "wind_angle": self.wind_angle_input.value(),
                "coriolis": self.coriolis_check.isChecked(),
                "latitude": self.latitude_input.value()
            }
            self.presets[name] = preset
            self.save_presets()
            self.refresh_preset_combo()
            self.preset_combo.setCurrentText(name)
            QMessageBox.information(self, "Preset Saved", f"Preset '{name}' saved.")

    def delete_preset(self):
        name = self.preset_combo.currentText()
        if name in self.default_presets:
            QMessageBox.warning(self, "Cannot Delete", "Default presets cannot be deleted.")
            return
        if name in self.presets:
            reply = QMessageBox.question(
                self, "Delete Preset", f"Delete preset '{name}'?", QMessageBox.Yes | QMessageBox.No)
            if reply == QMessageBox.Yes:
                del self.presets[name]
                self.save_presets()
                self.refresh_preset_combo()
                QMessageBox.information(self, "Preset Deleted", f"Preset '{name}' deleted.")

    def load_custom_drag_curve(self):
        path, _ = QFileDialog.getOpenFileName(self, "Load Custom Drag Curve", "", "CSV Files (*.csv)")
        if not path:
            return
        curve = []
        try:
            with open(path, "r") as f:
                reader = csv.reader(f)
                for row in reader:
                    if len(row) >= 2:
                        v, cd = float(row[0]), float(row[1])
                        curve.append((v, cd))
            self.custom_drag_curve = curve
            self.drag_model_combo.setCurrentText("Custom")
            QMessageBox.information(self, "Custom Drag Loaded", "Custom drag curve loaded successfully.")
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Failed to load drag curve: {e}")

    def toggle_dark_mode(self):
        self.dark_mode_enabled = not self.dark_mode_enabled
        self.apply_styles()
        self.save_config()

    def toggle_units(self):
        self.use_imperial = self.units_chk.isChecked()
        self.save_config()
        # Optionally convert displayed values here

    def validate_inputs(self):
        if self.mass_input.value() <= 0:
            QMessageBox.warning(self, "Input Error", "Projectile mass must be positive.")
            return False
        if self.diam_input.value() <= 0:
            QMessageBox.warning(self, "Input Error", "Projectile diameter must be positive.")
            return False
        if self.velocity_input.value() <= 0:
            QMessageBox.warning(self, "Input Error", "Muzzle velocity must be positive.")
            return False
        return True

    def calculate_trajectory(self):
        if not self.validate_inputs():
            return
        params = {
            "mass": self.mass_input.value() / 1000,  # g to kg
            "diameter": self.diam_input.value() / 1000,  # mm to m
            "velocity": self.velocity_input.value(),
            "angle": self.angle_input.value(),
            "drag_model": self.drag_model_combo.currentText(),
            "projectile_type": self.type_combo.currentText().lower(),
            "burn_time": self.burn_time_input.value(),
            "thrust": self.thrust_input.value(),
            "custom_drag_curve": self.custom_drag_curve,
            "altitude": self.altitude_input.value(),
            "temperature": self.temp_input.value(),
            "pressure": self.pressure_input.value(),
            "humidity": self.humidity_input.value(),
            "wind_speed": self.wind_speed_input.value(),
            "wind_angle": self.wind_angle_input.value(),
            "coriolis": self.coriolis_check.isChecked(),
            "latitude": self.latitude_input.value()
        }
        self.status_bar.showMessage("Calculating trajectory...")
        self.calculate_btn.setEnabled(False)
        thread = CalculationThread(self, params)
        thread.finished.connect(self.on_trajectory_calculated)
        thread.error.connect(self.on_calculation_error)
        thread.start()
        self._calc_thread = thread  # prevent garbage collection

    def on_trajectory_calculated(self, result):
        self.trajectory = result
        self.previous_trajectories.append(result)
        self.update_results_tab()
        self.update_plot_tab()
        self.status_bar.showMessage("Calculation complete.")
        self.calculate_btn.setEnabled(True)

    def on_calculation_error(self, error):
        QMessageBox.warning(self, "Calculation Error", error)
        self.status_bar.showMessage("Error during calculation.")
        self.calculate_btn.setEnabled(True)

    # ...continues with update_results_tab, update_plot_tab, _calculate_trajectory, export_results, export_plot, export_to_csv, export_plot_to_png, export_presets, import_presets, run_batch, run_monte_carlo, show_about, etc...
    def update_results_tab(self):
        # Summary
        if not self.trajectory or not isinstance(self.trajectory, list):
            self.summary_text.setPlainText("No results.")
            self.data_text.setPlainText("")
            return
        try:
            tmax = max(row[0] for row in self.trajectory)
            xmax = max(row[1] for row in self.trajectory)
            hmax = max(row[2] for row in self.trajectory)
            vimpact = abs(self.trajectory[-1][3])
            summary = (
                f"Time of Flight: {tmax:.2f} s\n"
                f"Range: {xmax:.2f} m\n"
                f"Max Height: {hmax:.2f} m\n"
                f"Impact Velocity: {vimpact:.2f} m/s"
            )
            self.summary_text.setPlainText(summary)
        except Exception as e:
            self.summary_text.setPlainText(f"Error: {e}")

        # Data Table
        lines = ["time (s), x (m), y (m), v (m/s), angle (deg)"]
        for row in self.trajectory:
            lines.append(",".join(f"{v:.3f}" for v in row))
        self.data_text.setPlainText("\n".join(lines))

    def update_plot_tab(self):
        self.figure.clear()
        ax = self.figure.add_subplot(111)
        if self.trajectory:
            xs = [row[1] for row in self.trajectory]
            ys = [row[2] for row in self.trajectory]
            ax.plot(xs, ys, label="Current Trajectory", color="blue")
        if self.compare_check.isChecked() and len(self.previous_trajectories) > 1:
            prev = self.previous_trajectories[-2]
            xs = [row[1] for row in prev]
            ys = [row[2] for row in prev]
            ax.plot(xs, ys, label="Previous", color="gray", linestyle="dashed")
        ax.set_xlabel("Distance (m)")
        ax.set_ylabel("Height (m)")
        ax.legend()
        ax.grid(True)
        self.figure.tight_layout()
        self.canvas.draw()

    def _calculate_trajectory(
        self, mass, diameter, velocity, angle, drag_model, projectile_type,
        burn_time, thrust, custom_drag_curve, altitude, temperature, pressure,
        humidity, wind_speed, wind_angle, coriolis, latitude
    ):
        dt = 0.01  # time step
        angle_rad = math.radians(angle)
        proj = Projectile(
            mass=mass,
            diameter=diameter,
            drag_model=drag_model,
            velocity=velocity,
            projectile_type=projectile_type,
            burn_time=burn_time,
            thrust_curve={0: thrust, burn_time: 0} if projectile_type == "rocket" else None,
            custom_drag_curve=custom_drag_curve
        )
        env = Environment(
            altitude=altitude,
            temperature=temperature,
            pressure=pressure,
            humidity=humidity,
            wind_speed=wind_speed,
            wind_angle=wind_angle,
            coriolis=coriolis,
            latitude=latitude
        )
        x, y = 0.0, 0.0
        vx = velocity * math.cos(angle_rad)
        vy = velocity * math.sin(angle_rad)
        t = 0.0
        traj = []
        while y >= 0:
            v = math.hypot(vx, vy)
            cd = proj.drag_coefficient(v)
            rho = env.air_density
            f_drag = 0.5 * cd * rho * proj.area * v * v
            ax = -f_drag * vx / (proj.get_mass(t) * v)
            ay = -GRAVITY - (f_drag * vy) / (proj.get_mass(t) * v)
            if projectile_type == "rocket" and t <= burn_time:
                thrust_now = proj.get_thrust(t)
                ax += thrust_now * math.cos(angle_rad) / proj.get_mass(t)
                ay += thrust_now * math.sin(angle_rad) / proj.get_mass(t)
            # Wind
            wx = env.wind_speed * math.cos(math.radians(env.wind_angle))
            wy = env.wind_speed * math.sin(math.radians(env.wind_angle))
            vx_rel = vx - wx
            vy_rel = vy - wy
            v_rel = math.hypot(vx_rel, vy_rel)
            # Update velocity with wind relative drag
            cd_rel = proj.drag_coefficient(v_rel)
            f_drag_rel = 0.5 * cd_rel * rho * proj.area * v_rel * v_rel
            ax -= f_drag_rel * vx_rel / (proj.get_mass(t) * v_rel)
            ay -= f_drag_rel * vy_rel / (proj.get_mass(t) * v_rel)
            if coriolis:
                f_cor = 2 * proj.get_mass(t) * EARTH_ROTATION_RATE * vy * math.sin(math.radians(latitude))
                ax += f_cor / proj.get_mass(t)
            vx += ax * dt
            vy += ay * dt
            x += vx * dt
            y += vy * dt
            t += dt
            traj.append([t, x, y, math.hypot(vx, vy), math.degrees(math.atan2(vy, vx))])
            if y < 0:
                break
        return traj

    def export_results(self):
        if not self.trajectory:
            QMessageBox.warning(self, "No Data", "No trajectory to export.")
            return
        path, _ = QFileDialog.getSaveFileName(self, "Export Results", "", "CSV Files (*.csv)")
        if not path:
            return
        try:
            with open(path, "w", newline="") as f:
                writer = csv.writer(f)
                writer.writerow(["time (s)", "x (m)", "y (m)", "v (m/s)", "angle (deg)"])
                for row in self.trajectory:
                    writer.writerow(row)
            QMessageBox.information(self, "Export Complete", f"Results exported to {path}.")
        except Exception as e:
            QMessageBox.warning(self, "Export Error", str(e))

    def export_plot(self):
        if not self.trajectory:
            QMessageBox.warning(self, "No Data", "No plot to export.")
            return
        path, _ = QFileDialog.getSaveFileName(self, "Export Plot", "", "PNG Files (*.png)")
        if not path:
            return
        try:
            self.figure.savefig(path)
            QMessageBox.information(self, "Export Complete", f"Plot exported to {path}.")
        except Exception as e:
            QMessageBox.warning(self, "Export Error", str(e))

    def export_to_csv(self):
        self.export_results()

    def export_plot_to_png(self):
        self.export_plot()

    def export_presets(self):
        path, _ = QFileDialog.getSaveFileName(self, "Export Presets", "", "JSON Files (*.json)")
        if not path:
            return
        try:
            with open(path, "w") as f:
                json.dump(self.presets, f, indent=2)
            QMessageBox.information(self, "Export Complete", f"Presets exported to {path}.")
        except Exception as e:
            QMessageBox.warning(self, "Export Error", str(e))

    def import_presets(self):
        path, _ = QFileDialog.getOpenFileName(self, "Import Presets", "", "JSON Files (*.json)")
        if not path:
            return
        try:
            with open(path, "r") as f:
                presets = json.load(f)
                self.presets.update(presets)
                self.save_presets()
                self.refresh_preset_combo()
            QMessageBox.information(self, "Import Complete", "Presets imported.")
        except Exception as e:
            QMessageBox.warning(self, "Import Error", str(e))

    def run_batch(self):
        param = self.batch_param_combo.currentText()
        start = self.batch_start_input.value()
        end = self.batch_end_input.value()
        step = self.batch_step_input.value()
        batch_params = []
        for val in self._frange(start, end, step):
            params = {
                "mass": self.mass_input.value() / 1000,
                "diameter": self.diam_input.value() / 1000,
                "velocity": self.velocity_input.value(),
                "angle": self.angle_input.value(),
                "drag_model": self.drag_model_combo.currentText(),
                "projectile_type": self.type_combo.currentText().lower(),
                "burn_time": self.burn_time_input.value(),
                "thrust": self.thrust_input.value(),
                "custom_drag_curve": self.custom_drag_curve,
                "altitude": self.altitude_input.value(),
                "temperature": self.temp_input.value(),
                "pressure": self.pressure_input.value(),
                "humidity": self.humidity_input.value(),
                "wind_speed": self.wind_speed_input.value(),
                "wind_angle": self.wind_angle_input.value(),
                "coriolis": self.coriolis_check.isChecked(),
                "latitude": self.latitude_input.value()
            }
            if param == "Angle":
                params["angle"] = val
            elif param == "Muzzle Velocity":
                params["velocity"] = val
            batch_params.append(params)
        self.batch_progress_bar.setValue(0)
        thread = BatchCalculationThread(self, batch_params)
        thread.progress.connect(self.batch_progress_bar.setValue)
        thread.finished.connect(self.on_batch_finished)
        thread.error.connect(self.on_calculation_error)
        thread.start()
        self._batch_thread = thread

    def _frange(self, start, end, step):
        vals = []
        x = start
        if step == 0:
            return vals
        if start < end:
            while x <= end:
                vals.append(x)
                x += step
        else:
            while x >= end:
                vals.append(x)
                x -= abs(step)
        return vals

    def on_batch_finished(self, results):
        self.batch_table.setRowCount(len(results))
        param = self.batch_param_combo.currentText()
        start = self.batch_start_input.value()
        step = self.batch_step_input.value()
        for i, traj in enumerate(results):
            if not traj:
                continue
            try:
                tmax = max(row[0] for row in traj)
                xmax = max(row[1] for row in traj)
                hmax = max(row[2] for row in traj)
                vimpact = abs(traj[-1][3])
                self.batch_table.setItem(i, 0, QTableWidgetItem(str(i+1)))
                param_val = start + i*step
                self.batch_table.setItem(i, 1, QTableWidgetItem(f"{param_val:.3f}"))
                self.batch_table.setItem(i, 2, QTableWidgetItem(f"{hmax:.3f}"))
                self.batch_table.setItem(i, 3, QTableWidgetItem(f"{xmax:.3f}"))
                self.batch_table.setItem(i, 4, QTableWidgetItem(f"{vimpact:.3f}"))
            except Exception:
                continue
        self.batch_progress_bar.setValue(100)

    def run_monte_carlo(self):
        runs = self.mc_runs_input.value()
        spread_angle = self.mc_spread_angle.value()
        spread_velocity = self.mc_spread_velocity.value()
        xhits = []
        yhits = []
        self.mc_progress_bar.setValue(0)
        for i in range(runs):
            angle = self.angle_input.value() + random.uniform(-spread_angle, spread_angle)
            velocity = self.velocity_input.value() + random.uniform(-spread_velocity, spread_velocity)
            traj = self._calculate_trajectory(
                mass=self.mass_input.value() / 1000,
                diameter=self.diam_input.value() / 1000,
                velocity=velocity,
                angle=angle,
                drag_model=self.drag_model_combo.currentText(),
                projectile_type=self.type_combo.currentText().lower(),
                burn_time=self.burn_time_input.value(),
                thrust=self.thrust_input.value(),
                custom_drag_curve=self.custom_drag_curve,
                altitude=self.altitude_input.value(),
                temperature=self.temp_input.value(),
                pressure=self.pressure_input.value(),
                humidity=self.humidity_input.value(),
                wind_speed=self.wind_speed_input.value(),
                wind_angle=self.wind_angle_input.value(),
                coriolis=self.coriolis_check.isChecked(),
                latitude=self.latitude_input.value()
            )
            xhits.append(traj[-1][1] if traj else 0)
            yhits.append(traj[-1][2] if traj else 0)
            self.mc_progress_bar.setValue(int((i+1)/runs*100))
        # Plot
        fig = self.mc_canvas.figure
        fig.clear()
        ax = fig.add_subplot(111)
        ax.scatter(xhits, yhits, alpha=0.5)
        ax.set_xlabel("X impact (m)")
        ax.set_ylabel("Y impact (m)")
        ax.set_title("Monte Carlo Impact Distribution")
        fig.tight_layout()
        self.mc_canvas.draw()
        self.mc_progress_bar.setValue(100)

    def show_about(self):
        QMessageBox.information(
            self, "About",
            "AcuTex Ballistic Calculator Ultimate Edition\n"
            "Â© 2025 DriftWorks Labs\n"
            "GitHub: github.com/AdmiralDrift868\n"
            "Open source under the MIT License."
        )

if __name__ == "__main__":
    app = QApplication(sys.argv)
    calculator = BallisticCalculator()
    calculator.show()
    sys.exit(app.exec_())
